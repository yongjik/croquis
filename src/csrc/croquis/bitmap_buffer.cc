// Bitmap buffer for drawing lines with AVX intrinsics.

#include "croquis/bitmap_buffer.h"

#include <assert.h>
#include <math.h>  // sqrtf
#include <stdint.h>  // uint64_t
#include <stdio.h>  // printf (for debugging)
#include <string.h>  // memcpy

#include <immintrin.h>

#include "croquis/util/avx_util.h"

// #define DEBUG_BITMAP 0

namespace croquis {

// Branch-free bitmask.  (Not sure how much it matters, though ...)
// Given n, zeroes out least n bits.
// If n < 0, returns 0xffffffff.
// If n > 32, returns zero.
static inline uint32_t zero_lower_bits(int n)
{
    return -(n < 0) | (-(n < 32) & (-1 << n));
}

// Transform the ymm register (32x8) to four blocks of size 8x8.
// I.e., the original has pixels from:
//      LSB = (0,0), (1,0), (2,0), ..., (31,0)
//            (0,1), (1,1), (2,1), ..., (31,1)
//            ................................
//            (0,7), (1,7), (2,7), ..., (31,7) = MSB
//
// We transform it into:
//      Block #0:
//          LSB = (0,0), (1,0), (2,0), ..., (7,0)
//                (0,1), (1,1), (2,1), ..., (7,1)
//                ...............................
//                (0,7), (1,7), (2,7), ..., (7,7)
//      ........
//      Block #3:
//                (24,0), (25,0), (26,0), ..., (31,0)
//                (24,1), (25,1), (26,1), ..., (31,1)
//                ...................................
//                (24,7), (25,7), (26,7), ..., (31,7) = MSB
//
// Or, if we consider the input as byte #0 .. byte #31, then the output has:
//      byte #0, #4, #8, #12, #16, #20, #24, #28 : block #0
//      byte #1, #5, #9, #13, #17, #21, #25, #29 : block #1
//      byte #2, #6, #10, #14, #18, #22, #26, #30 : block #2
//      byte #3, #7, #11, #15, #19, #23, #27, #31 : block #3.
static inline __m256i shuffle_to_blks(__m256i a)
{
    // MSB first.
    const __m256i idxs1 = _mm256_set_epi32(
        0x0f0b0703, 0x0e0a0602, 0x0d090501, 0x0c080400,
        0x0f0b0703, 0x0e0a0602, 0x0d090501, 0x0c080400);

    // Unfortunately, vpshufb cannot cross 128-bit lanes.
    __m256i b = _mm256_shuffle_epi8(a, idxs1);  // vpshufb

    const __m256i idxs2 = _mm256_set_epi32(
        0x07, 0x03, 0x06, 0x02, 0x05, 0x01, 0x04, 0x00);

    return _mm256_permutevar8x32_epi32(b, idxs2);  // vpermd
}

// Read four 64-bit words (= blocks) starting at buf[offset], bit-OR with `blks`
// (generated by shuffle_to_blks()), and store it back.  If any block
// transitions from zero to nonzero, also record the offset to `blklist`.
//
// We assume that buf[offset] is 32-byte aligned.
inline void BitmapBuffer::store_blks(uint16_t offset, __m256i blks)
{
    const __m256i zeros = _mm256_setzero_si256();

    __m256i *ptr = (__m256i *) &(buf[offset]);
    __m256i orig = _mm256_load_si256(ptr);  // vmovdqa
    _mm256_store_si256(ptr, _mm256_or_si256(blks, orig));  // vpor, vmovdqa

#ifdef DEBUG_BITMAP
    {
        alignas(32) int d[8];

        printf("offset=%d blks = ", (int) offset);
        _mm256_store_si256((__m256i *) d, blks);
        for (int i = 7; i >= 0; i--) {
            printf("[%d]%08x ", i, d[i]);
        }
        printf("\n");
    }
#endif

    __m256i orig_is_zero = _mm256_cmpeq_epi64(orig, zeros);  // vpcmpeqq
    __m256i is_changed = _mm256_and_si256(orig_is_zero, blks);  // vpand
    __m256i mask = _mm256_cmpeq_epi64(is_changed, zeros);  // vpcmpeqq

    // 0 iff block transitioned from zero to nonzero.
    int blk_mask = _mm256_movemask_pd(_mm256_castsi256_pd(mask));  // vmovmskpd

    // We want to store only blocks that transitioned to nonzero.
    // Note that a zero bit means we store the index.
    static const uint32_t table[] = {
        0x03020100,  // 0000: 3 2 1 0
        0xff030201,  // 0001: 3 2 1
        0xff030200,  // 0010: 3 2 0
        0xffff0302,  // 0011: 3 2

        0xff030100,  // 0100: 3 1 0
        0xffff0301,  // 0101: 3 1
        0xffff0300,  // 0110: 3 0
        0xffffff03,  // 0111: 3

        0xff020100,  // 1000: 2 1 0
        0xffff0201,  // 1001: 2 1
        0xffff0200,  // 1010: 2 0
        0xffff0002,  // 1011: 2

        0xffff0100,  // 1100: 1 0
        0xffffff01,  // 1101: 1
        0xffffff00,  // 1110: 0
        0xffffffff,  // 1111: none
    };

    static const uint8_t blk_cnts[] = {
        0x04, 0x03, 0x03, 0x02, 0x03, 0x02, 0x02, 0x01,
        0x03, 0x02, 0x02, 0x01, 0x02, 0x01, 0x01, 0x00
    };

    __m128i incrs = _mm_cvtsi32_si128(table[blk_mask]);  // vmovd
    incrs = _mm_cvtepi8_epi16(incrs); // vpmovsxbw
    __m128i offsets = _mm_add_epi16(incrs, _mm_set1_epi16(offset));  // vpaddw

    uint16_t *blklist_ptr = &blklist[blk_cnt];
    blk_cnt += blk_cnts[blk_mask];

    // _mm_storeu_si64 is not supported on gcc<9.
#if defined(__GNUC__) && !defined(__clang__) && (__GNUC__ < 9)
    memcpy((void *) blklist_ptr, &offsets, 8);
#else
    _mm_storeu_si64((void *) blklist_ptr, offsets);  // vmovq
        // Memory need not be aligned for this.
#endif
}

// Example line drawing code, from (x0, y0) to (x1, y1).
//
// For now, we assume: 0 <= (y1 - y0) < (x1 - x0).
//
// `buf` is made of 64x64 64-bit blocks, where each "block" contains 8x8 pixels
// - so the total resolution is 512x512 pixels.
//
// To simplify reasoning, here we will pretend that we're using ordinary
// cartesian coordinates: "up" or "higher" means higher y coordinate.  To revert
// back to the screen coordinate system, simply imagine that the whole drawing
// area is reflected upside down.
void BitmapBuffer::draw_line(float x0, float y0, float x1, float y1,
                             float width)
{
    const __m256i zeros = _mm256_setzero_si256();
    const __m256i all_ones = _mm256_set1_epi8(0xff);

    const float dx = x1 - x0;
    const float dy = y1 - y0;

    // invlen: 1 / (length of the line).
    // wx, wy: half-width lateral displacement of the line.
    //
    // Lower Edge:  from (x0 + wx, y0 - wy) to (x1 + wx, y1 - wy)
    // Higher Edge: from (x0 - wx, y0 + wy) to (x1 - wx, y1 + wy)
    //
    // With -ffast-math, we can just use sqrtf() and clang will change it to AVX
    // intrinsics (vrsqrtss) instead of a library call.
    const float len = sqrtf(dx * dx + dy * dy);
    const float wx = dy * (width / (2 * len));
    const float wy = dx * (width / (2 * len));

    // For now, we assume: 0 <= dy < dx.
    assert(0 <= dy && dy < dx);

    // Compute the bounding box: we only touch pixels inside this box.
    // (This is easier and hopefully faster than correctly drawing the short
    // edge at either end of the line - the ends will be overpainted by markers
    // with the same size as the line width, so it does not matter.)
    const int xmin = nearbyintf(x0 - wx);
    const int xmax = nearbyintf(x1 + wx);
    const int ymin = nearbyintf(y0 - wy);
    const int ymax = nearbyintf(y1 + wy);

    // Compute the slope and the y-intercept of lower/higher lines.
    const float slope = dy / dx;
    const float yL = (y0 - wy) - slope * (x0 + wx);
    const float yH = (y0 + wy) - slope * (x0 - wx);

#ifdef DEBUG_BITMAP
    printf("orig xmin = %.4f\n", x0 - wx);
    printf("len wx wy = %.4f %.4f %.4f\n", len, wx, wy);
    printf("xmin xmax ymin ymax = %d %d %d %d\n", xmin, xmax, ymin, ymax);
    printf("slope = %.4f yL = %.4f yH = %.4f\n", slope, yL, yH);
#endif

    // Find the coordinate of the first 32x8 block to process.
    int xblk, yblk;
    if (xmin >= 0 && ymin >= 0) {
        // If (xmin, ymin) is inside the drawing area, we can start from there.
        xblk = xmin / 32;
        yblk = ymin / 8;
    }
    else {
        // The line starts outside the drawing area.
        if (yH >= 0) {
            // If yH >= 0, then the higher line passes above (0, 0).  Hence, the
            // left-bottom corner can start at (0, yL).
            xblk = 0;
            yblk = ceilf(yL) / 8;
            if (yblk < 0) yblk = 0;
        }
        else {
            // If the higher line passes below (0, 0), then find its
            // x-intercept.  To guard against overflow, let's first check if the
            // x-intercept is to the right of the drawing area, in which case
            // there's nothing to draw.
            if (slope * (x0 - wx - 513) > y0 + wy) return;
            const float xH = (x0 - wx) - (y0 + wy) / slope;
            xblk = ceilf(xH) / 32;
            yblk = 0;
        }
    }

    if (xblk >= (512 / 32) || yblk >= (512 / 8)) return;

    const int sx = xblk * 32;
    const int sy = yblk * 8;

    const float SLOPE_THRESHOLD = 1.f / 512;
    float inv_slope = dx / (dy + 1e-10);
    __m256i xL_plus1, xH_plus1;
    float up_incr;
    if (slope < SLOPE_THRESHOLD) {
        //----------------------------------------
        // Special case if the slope is too close to zero: since we need
        // 1/slope, we may have overflow.  Fortunately, if the slope is lower
        // than threshold, then it will vertically span only *one* row per line
        // - one at ceil(yL) and another at ceil(yH).  Hence, we can just
        // compute these points.

        const float xlimit = 512 * 256.f;
        const static char pattern[] = "\x00\x00\x00\x00\x00\x00\x00"
                                      "\xfc\xf8\xf8\xf8\xf8\xf8\xf8";

        // Keep a large enough increment so that we don't get any pixels in
        // other rows.
        up_incr = 512 * 256;

        //----------------------------------------
        // First, compute the lower line.
        const int rowL = ceilf(yL);
        float xL1_plus1 = ((rowL - yL) * inv_slope + 1) * 256.f;
        xL1_plus1 = (xL1_plus1 < xlimit) ? xL1_plus1 : xlimit;

        // Create bitmask.
        // maskL0: above rowL = 0xf8 / rowL = 0xfc / below rowL = 0x00
        // Final maskL (Note that it's applied as inverted):
        //      above rowL: maskL = 0xfff80000 ; ~maskL = 0x0007ffff
        //            rowL: maskL = 0xfffc0000 ; ~maskL = 0x0003ffff
        //      below rowL: maskL = 0x00000000 ; ~maskL = 0xffffffff
        int idxL = rowL & 0x07;
        __m128i patL = _mm_loadu_si64((void *) (pattern + 7 - idxL));  // movq
        __m256i maskL = _mm256_cvtepi8_epi32(patL);  // vpmovsxbd
        maskL = _mm256_slli_epi32(maskL, 16);  // vpslld

        // xL_plus1: above rowL: xL1_plus1 + (1024 * 256)
        //                 rowL: xL1_plus1
        //           below rowL: xL1_plus1 - (1024 * 256)
        __m256i tmpL =
            _mm256_set1_epi32(int(nearbyintf(xL1_plus1)) | 0xfffc0000);
        xL_plus1 = _mm256_andnot_si256(maskL, tmpL);  // vpandn

        // Now translate to the current block.
        int incrL = (sy - (rowL & ~0x07)) * up_incr - (sx * 256);
        xL_plus1 = _mm256_add_epi32(xL_plus1, _mm256_set1_epi32(incrL));

        //----------------------------------------
        // Same for the higher line.
        const int rowH = ceilf(yH);
        float xH1_plus1 = ((rowH - yH) * inv_slope + 1) * 256.f;
        xH1_plus1 = (xH1_plus1 < xlimit) ? xH1_plus1 : xlimit;

        int idxH = rowH & 0x07;
        __m128i patH = _mm_loadu_si64((void *) (pattern + 7 - idxH));  // movq
        __m256i maskH = _mm256_cvtepi8_epi32(patH);  // vpmovsxbd
        maskH = _mm256_slli_epi32(maskH, 16);  // vpslld

        __m256i tmpH =
            _mm256_set1_epi32(int(nearbyintf(xH1_plus1)) | 0xfffc0000);
        xH_plus1 = _mm256_andnot_si256(maskH, tmpH);  // vpandn

        // Now translate to the current block.
        int incrH = (sy - (rowH & ~0x07)) * up_incr - (sx * 256);
        xH_plus1 = _mm256_add_epi32(xH_plus1, _mm256_set1_epi32(incrH));

#ifdef DEBUG_BITMAP
        printf("rowL=%d rowH=%d sy=%d\n", rowL, rowH, sy);
        printf("incrL=%d incrH=%d\n", incrL, incrH);
        printf("xL_plus1 = %s\n", util::to_string(xL_plus1).c_str());
        printf("xH_plus1 = %s\n", util::to_string(xH_plus1).c_str());
#endif
    }
    else {
        // We use fixed point format (24-bit integer part + 8-bit fraction).
        // NOTE: For xL & xH, we use floor instead of round - for example, if xL
        //       is 12.1 or 12.9, then pixel 12 is selected and 13 isn't - the
        //       line passes between these two pixels.
        int xL = ((x0 + wx) + inv_slope * (sy - (y0 - wy)) - sx) * 256;
        int xH = ((x0 - wx) + inv_slope * (sy - (y0 + wy)) - sx) * 256;

#ifdef DEBUG_BITMAP
        printf("sx sy = %d %d\n", sx, sy);
        printf("inv_slope = %.4f\n", inv_slope);
        printf("x0 + wx = %.4f\n", x0 + wx);
        printf("y0 + wy = %.4f\n", y0 + wy);
        printf("xL xH = %d (%.4f) %d (%.4f)\n", xL, xL/256., xH, xH/256.);
#endif

        __m256 steps_float =
            _mm256_mul_ps(  // vmulps
                _mm256_set1_ps(inv_slope),
                _mm256_set_ps(
                    7 * 256.f, 6 * 256.f, 5 * 256.f, 4 * 256.f,
                    3 * 256.f, 2 * 256.f, 1 * 256.f, 0 * 256.f));

        // This applies rounding according to the MXCSR register - seems like it
        // does correct rounding (rounding to nearest even) by default.
        __m256i steps = _mm256_cvtps_epi32(steps_float);  // vcvtps2dq

        xL_plus1 = _mm256_add_epi32(_mm256_set1_epi32(xL + 256), steps);
        xH_plus1 = _mm256_add_epi32(_mm256_set1_epi32(xH + 256), steps);
        up_incr = inv_slope * 256;
    }

    // Compute bitmask for allowed y range (ymin--ymax).
    // `ycoords` is shifted so that `ymin` becomes INT_MIN, so
    // (ycoords < INT_MIN + ymax - ymin + 1) iff y is in [ymin, ymax].
    __m256i ythreshold = _mm256_set1_epi32(ymax - ymin - 0x80000000U + 1);
    __m256i ycoords =
        _mm256_add_epi32(  // vpaddd
            _mm256_set1_epi32(yblk * 8 - ymin - 0x80000000U),
            _mm256_set_epi32(7, 6, 5, 4, 3, 2, 1, 0));
    int down_cnt = 0;

    while (true) {
        int disp = nearbyintf((yblk * 8 - sy) * up_incr) -
                   (xblk * 32 - sx) * 256;
        __m256i this_xL_plus1 =
            _mm256_add_epi32(xL_plus1, _mm256_set1_epi32(disp));  // vpaddd
        __m256i this_xH_plus1 =
            _mm256_add_epi32(xH_plus1, _mm256_set1_epi32(disp));  // vpaddd

        // Shift coordinates to get the integer part.
        __m256i xL_plus1_int = _mm256_srai_epi32(this_xL_plus1, 8);  // vpsrad
        __m256i xH_plus1_int = _mm256_srai_epi32(this_xH_plus1, 8);  // vpsrad

#ifdef DEBUG_BITMAP
        {
            int d[8];

            printf("(x,y) = (%d, %d)\n", xblk * 32, yblk * 8);
            printf("disp = %d = %.4f\n", disp, disp / 256.f);

            printf("xL_plus1 = %s\n", util::to_string(this_xL_plus1).c_str());
            memcpy((void *) d, (void *) &this_xL_plus1, 32);
            for (int i = 0; i < 7; i++) {
                int y = yblk * 8 + i;
                printf("xL_plus1[%d] = %d = %.4f\n", y, d[i], d[i] / 256.);

                float xL = (x0 + wx) + dx / dy * (y - (y0 - wy));
                float rel = xL + 1 - (xblk * 32);
                printf("Actual xL+1 = %.4f = %d + %.4f (err = %.4f)\n",
                       xL + 1, xblk * 32, rel, d[i] / 256. - rel);
            }

            printf("xH_plus1 = %s\n", util::to_string(this_xH_plus1).c_str());
            memcpy((void *) d, (void *) &this_xH_plus1, 32);
            for (int i = 0; i < 7; i++) {
                int y = yblk * 8 + i;
                printf("xH_plus1[%d] = %d = %.4f\n", y, d[i], d[i] / 256.);

                float xH = (x0 - wx) + dx / dy * (y - (y0 + wy));
                float rel = xH + 1 - (xblk * 32);
                printf("Actual xH+1 = %.4f = %d + %.4f (err = %.4f)\n",
                       xH + 1, xblk * 32, rel, d[i] / 256. - rel);
            }
        }
#endif

        // Use the coordinate to compute bitmask:
        //
        // range of x   xL_plus1_int    maskL
        // <-1          <0              0xffffffff (NOTE1)
        // [-1, 0)      0               0xffffffff
        // [0, 1)       1               0xfffffffe
        // ......
        // [30, 31)     31              0x80000000
        // >=31         32+             0x00000000 (NOTE2)
        //
        // NOTE: If a bit is set, then the corresponding pixel is to the right
        // (below) of the line.  Hence, maskL is "inverted": if a bit is set,
        // then it's below the lower line and the pixel should not be painted.
        //
        // NOTE1: We use vpmaxsd to clamp shift count to zeros.
        //
        // NOTE2: vpsllvd conveniently zeros out all bits if coordinate is not
        //        between [0, 32).
        __m256i shiftL = _mm256_max_epi32(xL_plus1_int, zeros);  // vpmaxsd
        __m256i maskL = _mm256_sllv_epi32(all_ones, shiftL);  // vpsllvd
        __m256i shiftH = _mm256_max_epi32(xH_plus1_int, zeros);  // vpmaxsd
        __m256i maskH = _mm256_sllv_epi32(all_ones, shiftH);  // vpsllvd
        __m256i pixels = _mm256_andnot_si256(maskL, maskH);
                         // vpandn: pixels = (~maskL) & maskH;

        // Apply the bounding box.
        int xmask = zero_lower_bits(xmin - xblk * 32) &
                    ~zero_lower_bits(xmax + 1 - xblk * 32);
        __m256i ymask = _mm256_cmpgt_epi32(ythreshold, ycoords);
        pixels = _mm256_and_si256(pixels, _mm256_set1_epi32(xmask));  // vpand
        pixels = _mm256_and_si256(pixels, ymask);  // vpand

        // Rearrange bitmask into four 8x8 blocks, and store them back to the
        // drawing area.
        __m256i blks = shuffle_to_blks(pixels);
        store_blks(yblk * 64 + xblk * 4, blks);

        // Check the MSB of the bit pattern (i.e., top right pixel).
        // (1) If the lower line passes below the pixel (i.e., maskL's MSB ==
        //     0), then we have to process the block to the right later.
        int check_right = (_mm256_movemask_epi8(maskL) >= 0);  // vpmovmskb

        // (2) If the higher line passes above the pixel (i.e., maskH's MSB ==
        //     1), then we need to move up.
        int up = (_mm256_movemask_epi8(maskH) < 0) &  // vpmovmskb
                 (yblk < 63) & ((yblk + 1) * 8 <= ymax);
        __m256i mask_up = _mm256_set1_epi32(-up);

        // If both `check_right` and `up` is true, then increment `down_cnt` so
        // that we can find the correct staring point after moving right later.
        //
        // For example, if we move like this:
        //
        //      (3, 4)       ...
        //        ^   \       ^
        //      (3, 3) \    (4, 3)
        //        ^     \     ^
        //      (3, 2)   -->(4, 2)
        //        ^
        //      (3, 1)
        //
        // Then:
        //      (3, 1) : up
        //      (3, 2) : up, check_right -> increment down_cnt
        //      (3, 3) : up, check_right -> increment down_cnt
        //      (3, 4) :     check_right -> apply and clear down_cnt
        //      (4, 2) ...
        down_cnt += (check_right & up);

#ifdef DEBUG_BITMAP
        if (xblk * 32 == 0 && yblk * 8 == 16) {
            printf("maskH = %s\n", util::to_string(maskH).c_str());
            printf("maskL = %s\n", util::to_string(maskL).c_str());
            printf("down_cnt = %d check_right = %d up = %d\n",
                   down_cnt, check_right, up);
        }
#endif

        xblk += !up;
        int yincr = up ? 1 : -down_cnt;
        yblk += yincr;
        ycoords = _mm256_add_epi32(ycoords, _mm256_set1_epi32(yincr * 8));

        down_cnt &= -up;  // "if (!up) down_cnt = 0;"

        if (xblk >= (512 / 32) || (xblk * 32) > xmax) return;
    }
}

} // namespace croquis
