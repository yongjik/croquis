Message formats between FE/BE
=============================

This document lists message formats: currently there's no schema enforcement, so
one should manually update this document whenever code changes.

Hopefully that's not too much effort.  (Using something like protocol buffer
would solve that problem, but it comes with its own dependency hassle ...)

CanvasConfigSubMessage:
    # The current (or new) canvas config.
    #
    # Mostly used by FE messages to contain the current canvas config, so that BE does
    # not have to remember canvas config.  (It seems cleaner that way.)
    #
    # Corresponds to CanvasConfig in C++ code.

    {
        config_id: 123,  # Canvas config ID.
        w: 600,  # Width of the canvas in pixels.
        h: 400,  # Height of the canvas in pixels.

        # Canvas area in data coordinates, assuming zoom_level == 0.
        x0: 0.123,
        y0: 0.234,
        x1: 987.654,
        y1: 876.543,

        # The current zoom level when this request was made.
        zoom_level: 1,

        # Offset in pixel coordinates for panning.  E.g., if (x_offset,
        # y_offset) = (10, 3), then the canvas is shifted 10 pixels to the right
        # and 3 pixels down.  See also TileSet.constructor().
        x_offset: 10,
        y_offset: 3,
    }

canvas_config_req (FE):
    # Tell BE that we need to generate a new canvas config - BE responds by
    # canvas_config (which fills in the details of the new config), and also
    # starts generating all the required tiles.

    {
        # Monotonically increasing config ID: generated by FE.
        config_id: 124,

        w: 800,  # Width of the canvas in pixels.
        h: 600,  # Height of the canvas in pixels.

        # 'reset': Generate a canvas that shows the whole data.
        # 'resize': Keep the given x0/y0/x1/y1, but change canvas size.
        # 'zoom': Generate a canvas zooming on the selected box.
        how: ('reset'|'resize'|'zoom'),

        # State of the current canvas config (just before resize/zoom), so that
        # BE can generate new canvas coordinates.
        # Absent if `how` is 'reset'.
        old_config: CanvasConfigSubMessage,

        # The selection area, in pixel coordinates.
        # Present only if `how` is 'zoom'.
        zoom: {
            px0: 1.234,
            py0: 2.345,
            px1: 9.876,
            py1: 8.765,
        },
    }

canvas_config (BE):
    # Returned as a response for canvas_config_req.

    {
        # `config_id`, `w`, and `h` are echoed back from `canvas_config_req`.
        # `zoom_level`, `x_offset`, and `y_ffset` are always 0 here.
        config: CanvasConfigSubMessage,

        # Added by axis_util.py: see Plotter._send_msg().
        axes: [
            x: [
                # Ticks for the x axis.
                [10, '0.0'],
                [25, '0.1'],
                [40, '0.2'],
                ...
            ],
            y: [
                # similar
            ],
        ],
    }

cell_fini (FE):
    # Called when the cell output is cleared, so that BE can free resources.
    # Contains no arguments.
    #
    # TODO: Not properly tested yet!

axis_req (FE):
    {
        config: CanvasConfigSubMessage,

        # Sequence number for this message so that FE can know which reply
        # corresponds to the latest request.
        axis_seq: 234,
    }

axis_ticks (BE):
    {
        config_id: 123,   # Existing config ID.
        axis_seq: 234,  # Seq #.

        # See above: ticks supplied in this message *also* have to be shifted in
        # the same way.
        x_offset: 10,
        y_offset: 3,

        axes: [
            # Same as in canvas_config.
        ]
    }

tile_req (FE):
    {
        # Sequence numbers for which we have received responses.
        ack_seqs: [123, 456, ...],

        # `x_offset` and `y_offset` are unused.
        config: CanvasConfigSubMessage,

        items: [
            {
                # For highlight tiles, only `id` is present.
                id: 123,  # Item ID for highlight tiles.

                # For non-highlight tiles, only `version` is present.
                # (Also, currently `reg` is empty for them.)
                #
                # For non-highlight tiles, we allow BE to *bump up* versions:
                # i.e., if version 234 is requested, by version 240 becomes
                # available while the message was enqueued, then we simply
                # generate tiles for version 240 and return it, because there's
                # not much point in generating *old* tiles.
                #
                # Also, if version is updated *while* we're generating tiles,
                # then the tile may contain inconsistent information, which is
                # indicated by having an odd version number in the response.
                version: 234,   # SelectionMap version for non-highlight tiles.

                # Prioritized tile coordinates (row:col:seq_no) that the cursor
                # may go through.  We expect BE to handle prioritized tiles
                # first.
                prio: ["3:4:100", "3:5:101", ...],

                # The remaining missing tiles.
                reg: ["2:3:105", "2:4:106", ...]
            },
            {
                id: 456,
                ...
            }
        ]

        # True if we could not send all tile requests, because there were
        # already too many in-flight requests.  (Currently only used by FE.)
        throttled: (true|false),
    }

tile (BE):
    # See Plotter::draw_tile_task() for details.
    #
    # This message also has attachments: the first is the PNG file data for the
    # tile, and the second (presents iff it is *not* a highlight tile, i.e.,
    # `item_id` is absent) is "hovermap", showing which item should be
    # highlighted for each pixel.
    {
        # Sequence numbers that belong to this tile: a string of colon-delimited
        # integers.
        #
        # Used for flow control: FE can now "forget" these sequence numbers,
        # reducing the number of in-flight tiles.  There can be multiple numbers
        # because of BE de-duplication.  (It's somewhat confusing, but if there
        # are duplicate requests we just attach old duplicate seq #'s to *any*
        # outgoing tile message, because it no longer contributes to the number
        # of in-flight requests.  See Plotter::InflightTileInfo for details.)
        seqs: "1234:1235:1236",

        # The SelectionMap version for this request.  Note that FE always
        # generates `sm_version` as an even number.  However, if SelectionMap
        # was changed while the tile was being generated, the number is
        # incremented (i.e., becomes odd) to indicate that it may be
        # inconsistent.
        sm_version: 10,

        config_id: 123,  # Current canvas config ID.
        zoom_level: 0,  # Current zoom level.
        row: 1,
        col: 2,

        # `item_id, `label`, and `style` are optional (present only for
        # highlight tiles).
        item_id: 123,

        # `label` and `style` are inserted by Python code.
        # `style` is in the same format as in message `labels`.
        #
        # This is inefficient, because for any given highlight request we will
        # send back multiple tiles with the same `item_id`, all with the same
        # label/style info.  However, compared to the size of PNG data, it
        # should be negligible.
        label: "red line #1",
        style: "ff0000:3:5",
    }

pt_req (FE):
    # Request information about the nearest point currently visible in the
    # canvas.

    {
        config: CanvasConfigSubMessage,

        # Mouse cursor position in pixel coordinate, measured from the current
        # visible top left corner.  (I.e., if x_offset = mouse_x = 0, it points
        # to the same location as in x_offset = mouse_x = 100.)
        mouse_x: 123,
        mouse_y: 45,

        item_id: 123,
    }

pt (BE):
    # Nearest point and its coordinate.

    {
        # Echoes back the arguments from `pt_req`.
        config: CanvasConfigSubMessage,
        mouse_x: 123,
        mouse_y: 45,
        item_id: 123,

        # Nearest point: data coordinate in string.
        data_x: "2021-06-22 22:00:00"
        data_y: "34.56"

        # Nearest point: screen coordinate.
        screen_x: 125,
        screen_y: 41,
    }

search (FE):
    {
        pat: pattern,
        regex: (true|false),

        # Optional: If given, behave as if update_selection (with how = 'exact')
        # was fired at the same time.  Used when autoselect is on.
        version: 200,
    }

labels (BE):
    {
        # Sends up to 200 items matching the requested search pattern.
        labels: [
            # item ID, selected (boolean), item label,
            # style = "rrggbb:(marker size):(line width)"
            [100, true, "red line #1", "ff0000:3:5"],
            ...
        ]
        count: 250,  # Number of total items matching the search pattern.
    }

update_selection (FE):
    {
        # Monotonically increasing version # for SelectionMap.
        # Must be always even: odd version numbers are used by BE to indicate
        # "SelectionMap update in progress"!
        version: 200,

        # 'select': select all in 'ids', or all matching 'pat'.
        # 'deselect': deselect all in 'ids', or all matching 'pat'.
        # 'exact': select exactly those in 'ids' or 'pat', and deselect
        #          everything else.
        how: ('select'|'deselect'|'exact'),

        # Either 'pat' and 'regex' are present, or 'ids'.
        pat: 'red line',
        regex: (true|false),
        ids: [1, 2, 3, 4, 5],
    }
