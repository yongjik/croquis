# Croquis: plot graphs 100x faster on Jupyter Notebook

Croquis is a lightweight Python library for drawing interactive graphs *really
fast* on Jupyter Notebook.  It lets you effortlessly browse and examine much
larger data than other similar libraries.

As an example, here's hourly ground temperature data of 2020 from the world's
weather stations, downloaded from [NOAA website](https://www.ncdc.noaa.gov/isd/data-access).
The data set contains 127 million points.

XXX video should be here XXX

The word "croquis" means [a quick, sketchy drawing](https://en.wikipedia.org/wiki/Croquis) -
it's from French *croquis* which simply means "sketch."  (The final -s is
silent: it's French, after all.)

## Requirements

- 64-bit Linux/Mac OS running on x86 with
  [AVX2](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#CPUs_with_AVX2)
  instruction set support.  (Intel: Haswell (2013) or later; AMD: Excavator
  (2015) or later.)
  - Windows support is under work.
  - Sorry, other architectures aren't supported yet.
- Python 3.6 or later.
- Jupyter Notebook.
- A modern browser (if it can run Jupyter Notebook, it's probably fine).

## How to install

```
pip install croquis
```

For building from the source, see [DEVELOPMENT.md](DEVELOPMENT.md).

To test if it's working correctly, try this inside Jupyter Notebook:

```
# Paste into a Jupyter cell.

import croquis
import numpy as np

N = 1000000
X = np.random.normal(size=(N, 1))
Y = np.random.normal(size=(N, 1))
labels=['pt %d' % i for i in range(N)]

fig = croquis.plot()
fig.add(X, Y, marker_size=3, labels=labels)
fig.show()
```

It should generate a plot like this:

![Gaussian distribution example](./doc/ex1.png)

See below for documentation.

By the way, this library is of course open source (MIT License) and totally free
to use, but just in case you really liked it for some reason, the author could
use a cup of coffee or two... :)

[![buy me a coffee](.github/donation-button.png)](https://www.buymeacoffee.com/yongjikkim)

## Limitations

Croquis is still experimental: as of version 0.1, we only support the **absolute
bare minimum** functionality.  In particular:

- Only line plots are supported, nothing else: no bars, pie charts, heatmaps, etc.
- All lines are solid: no dotted/dashed lines.
- All markers are solid circles: no other shapes are currently supported.
- No subplots: each Jupyter cell can contain only one graph.
- Very few options to customize the plot.  No titles, axis labels, or secondary axes.
- No support for mobile browsers.
- No dark mode.
- As you can see, the UI is rather primitive.

If croquis seems useful to you, but some features are missing for your use case,
then please feel free to file an issue.  (Of course I can't guarantee anything,
but it will be nice to know that someone's interested.)

## Documentation

Since it's currently very simple, there's not much to document.  Every graph is
created by running the following commands:

```
# Create the figure object.
fig = croquis.plot(...)

# Add one or more data sets.
fig.add(x1, y1, ...)
fig.add(x2, y2, ...)

# Generate the figure.
fig.show()
```

### `croquis.plot()`

This function currently has only two optional arguments:

* `x_axis='linear'` (**default**) interprets the x axis as ordinary numbers.
* `x_axis='timestamp'` interprets it as [POSIX timestamps](https://en.wikipedia.org/wiki/Unix_time).
  Timestamps are interpreted as UTC but displayed using the local timezone.
* `y_axis` behaves similarly.

### `fig.add(X, Y, colors=None, **kwargs)`

Each call may add a set of lines - scatter plots can be generated by adding
"lines" with a single point each, or by setting `line_width` to zero.  You can
call this function as many times as you want, but for best performance, it's
better to batch multiple lines into a single call to `fig.add()`.

* `X`, `Y`: Data points.

  Can be a Numpy array or something that can be transformed into a Numpy array.
  Data types can be any of: 8/16/32/64-bit signed/unsigned integer, `float`
  (i.e., `numpy.float32`), or `double` (i.e., `numpy.float64`).

  If dimension is `N` or `(1, N)` (for some `N`), then it is considered `N`
  points of a single line.  If dimension is `(M, N)` then it is considered `M`
  different lines, each with `N` data points.

  Broadcasting is supported, that is, one of `X` or `Y` can have dimension `N`
  or `(1, N)` and the other can have dimension `(M, N)` (where `M > 1`).

For example, the following are supported combinations.

```
fig.add([1, 2, 3], [4, 5, 6])  # Adds a single line with three points.

X = np.linespace(0, 10, 0.1)
fig.add(X, np.sin(X))  # Adds a single line.

X = np.array([[1, 2, 3, 4, 5], [2, 4, 6, 8, 10])
fig.add(X, np.sin(X))  # Adds two lines, each with five points.

# Broadcasting: adds 100 lines, each with 200 points.
# All lines share the same 200 x-coordinates.
X = np.linspace(0, 2 * np.pi, 200)
freqs = np.linspace(0, 1, 100).reshape(100, 1)
Y = np.sin(freqs * X)  # matrix of size 100 x 200
fig.add(X, Y)
```

* `color` (optional)

  If specified, must have dimension `(M, 3)`, where `M` is the number of lines.
  Can be either integer (range [0, 255]), or float (range [0.0, 1.0]).

  Currently, markers (if present) must have the same color as lines.

* `marker_size`, `line_width`, `highlight_line_width` (optional)

  Specifies the size of the marker, line width, and line width when a line is
  highlighted (by hovering).  Note that only circles are supported so far.

* `copy_data` (optional: default is `True`)

  If `False`, then croquis does not copy the arguments and instead holds a
  reference to the data.  Can reduce memory usage for huge data, but if the
  underlying data is modified while the graph is being used, bad things may
  happen.

* `start_idxs` (optional)

  Used for adding a batch of lines with an irregular number of points.  If
  specified, changes how we interpret `X` and `Y`: `X` and `Y` must be 1-D
  arrays with the same length, and `start_idxs` must be a monotonically
  increasing integer array indicating where each line starts.  For example:

```
# Contains three lines, with 3, 5, and 4 points each.
X =        [0, 1, 2, 0, 1, 2, 3, 4, 0, 1, 2, 3]
Y =        [1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3]
#           |        |              |
# line #0:  0  1  2  |              |
#      #1:           3  4  5  6  7  |
#      #2:                          8  9 10 11
start_idxs = [0, 3, 8]

fig.add(X, Y, start_idxs=start_idxs)
```

XXX what about labels ??

XXX add screenshot

XXX add a brief description of UI elements ..

## FAQ

### Is it really 100 times faster?

With large data, croquis can be *several hundred times* faster than other
popular libraries.  With very small data, there's less difference, as fixed-size
overheads start to dominate.

### Can we use it outside of Jupyter Notebook?

No, croquis is currently tied to Jupyter's message passing architecture, and all
computation is done in the backend, so it needs an active Jupyter Python
kernel.

### How does it work?

Unlike most other similar libraries, croquis works by running a C++ "tile
server," which computes fixed-sized "tiles" which is then sent back to the
browser.  If you have used Google Maps, the idea should be familiar.  This has
an important advantage:

- The browser only has to know about tiles.  Hence, the size of the data the
  browser needs to know is independent of the data set size.

As a result, the browser stays lean and "snappy" even with massive data.
(As explained above, we support `copy_data=False` option that even eliminates
data copies altogether.)

Moreover, unlike the browser's single-threaded javascript code, the C++-based
tile server can draw multiple tiles in parallel, which allows even more speedup.

(On the other hand, there are drawbacks - we have to basically re-implement every
graph drawing algorithm inside this tile server, not being able to use any
javascript API, except for very trivial things like coordinate grids.)
